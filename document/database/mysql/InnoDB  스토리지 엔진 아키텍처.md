바로 직전에는 MySQL 전체적인 구조를 살펴 보았다. 이번에는 MySQL 5.5 버전부터 기본 엔진이 된 InnoDB 스토리지 엔진에 대해 알아보고자 한다.

InnoDB는 MySQL의 모든 스토리지 엔진 중 **유일하게 레코드 기반의 잠금을 제공하고 있다. 때문에, 동시성 처리가 가능하고 안정적이다. 자, 이제 하나씩 알아보자.**

---

### InnoDB 구조 및 특징

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/57c8957e-86d4-42c3-8fc4-5d781c8ce661/Untitled.png)

위 이미지는 InnoDB의 구조도이다. 이 구조들이 어떻게 동작 하는지 하나씩 살펴보기 전 특징들을 잠시 알아보자.

1. **프라이머리 키에 의한 클러스터링**
    1. InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링 되어 저장된다. PK 값의 순서대로 디스크에 저장된다. 이 때문에 PK에 의한 레인지 스캔은 당연지사 빨리 처리될 수 밖에 없다. 그렇기 때문에 실행 계획에서 PK는 기본적으로 다른 보조 인덱스보다 선택될 확률이 높다.
2. **잠금이 필요없는 읽기**
    1. MVCC라는 구조를 통해 락을 걸지 않고 읽기 작업을 수행할 수 있다. 때문에 읽기 트랜잭션끼리는 락을 기다리지 않아도 되어 읽는 처리 속도가 빠르다.
3. **자동 데드락 감지**
    1. InnoDB는 그래프 기반의 데드락 체크 방식을 사용하기에 데드락이 발생하면 즉각 감지된다. 감지된 데드락에서 관련 트랜잭션 중 ROLLACK이 가장 용이한 트랜잭션(레코드를 가장 적게 변경한 트랜잭션)을 자동적으로 강제 종료한다. **때문에 쿼리가 제한시간에 도달하거나 슬로우 쿼리가 기록되는 경우는 거의 없다.**
4. **오라클 아키텍처 적용**
    1. InnoDB는 오라클의 기능과 상당 부분 비슷하다. MVCC 기능, 언두 데이터 관리 방법 등 오라클에 익숙한 사람은 InnoDB의 많은 부분들이 친숙하게 다가올 수 있다.

---

### InnoDB 버퍼 풀

InnoDB의 가장 핵심적인 부분으로 디스크의 데이터 파일, 인덱스 정보를 메모리에 ‘캐시’해 두는 공간이라고 말할 수 있다. **InnoDB는 write 시 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이하고 있다.** **데이터를 변경하는 쿼리는 마구자비로 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생하게 된다. 하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하게 되면 랜덤한 디스크 작업 횟수를 줄이게 된다.**

InnoDB의 버퍼 풀은 **데이터와 인덱스 모두 캐시하고 쓰기 버퍼의 역할까지 모두 처리한다.** 또, 버퍼 풀은 많은 백그라운드 작업의 기반이 되는 메모리 공간이라 크기 설정은 신중을 가해야한다.

- 다시 복귀해보는 시간 - **‘백그라운드 스레드’란?**

  인서트 버퍼를 병합하는 스레드 역할, 로그를 디스크로 기록하는 스레드, 버퍼 풀의 데이터를 디스크에 기록하는 스레드, 데이터를 버퍼로 읽어들이는 스레드, 잠금과 관련하여 데드락을 모니터링 하는 스레드, 모든 것을 총괄하는 메인 스레드가 존재한다.


InnoDB의 버퍼 풀은 디스크에 기록되지 않은 변경된 데이터를 가지고 있는데 이걸 더티 페이지라고 하며 주기적으로 특정 조건이 되면 이벤트가 발생하는데, 이때, 쓰기 스레드가 필요한 만큼의 더티 페이지만 디스크로 기록한다. 그렇다고 모든 것들을 디스크로 기록하지는 않는다.

---

### 언두(Undo) 로그

언두 영역은 `Update` 나 `Delete` 쿼리로 데이터를 변경했을 때 변경되기 전의 데이터를 저장하는 임시 보관소이다.

```sql
START TRANSACTION;

UPDATE member
SET name = '안성우'
WHERE member_name is null;

commit;
```

위 문장으로 봤을 때 Transaction 안에서 실행되어 commit 되기 전 update 쿼리문이 실행되고 이전에 `member_name` 컬럼이 null인 데이터는 언두 영역에 저장되어 있다.

이 언두 영역이 사용되는 이유는 크게 두가지가 있다.

1. 트랜잭션 롤백 대비용
2. 트랜잭션의 격리 수준을 유지 및 높은 동시성을 제공하는데 사용

---

### 인서트 버퍼(Insert Buffer)

데이터 베이스에서 레코드가 `Insert`되거나 `Update` 될 때 **데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트 하는 작업도 필요하다.** 그런데 인덱스를 업데이트 하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 상당히 많은 자원을 소모할 것이다.

그래서 InnoDB는 변경할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행한다. 하지만 버퍼 풀에 없다면 **디스크로부터 읽어와서 업데이트를 해야 한다면 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환한다. 이때 사용하는 임시 메모리 공간을 인서트 버퍼라고 한다.**

**사용자에게 결과를 바로 반환하기에 중복 체크 및 유니크 인덱스는 컬럼은 인서트 버퍼를 사용할 수 없다. 인서트 버퍼에 임시로 저장되어 있는 인덱스 레코드 조각은 백그라운드 스레드에 의해 병합된다.**

---

### MVCC(Multi Version Concurrency Control)

**레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이다.** MVCC의 가장 큰 목적은 잠금을 사용하지 않는 읽기를 제공한다는 점이다. InnoDB는 위에서 설명한 언두 로그를 이용해 이 기능을 구현한다.

격리 수준이 READ_COMMITED인 MySQL에서 하나씩 살펴보자.

```sql
CREATE TABLE MEMBER (
	m_id INT NOT NULL,
	m_name VARCHAR(20) NOT NULL,
	m_area VARCHAR(100) NOT NULL.

	PRIMARY KEY (m_id),
	INDEX ix_area (m_area)
);

INSERT INTO member (m_id, m_name, m_area)
VALUES (12,'홍길동','서울');
COMMIT;
```

위 `Insert`  쿼리가 시작되면 아래와 같이 바뀐다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/45aaf191-c9cf-40c3-800b-2e820544958d/Untitled.png)

그 다음 MEMBER 테이블에 `Update` 쿼리를 실행해보자.

```sql
UPDATE member 
SET m_area = '경기' 
WHERE m_id = 12;
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/165cffc6-5425-4e08-a760-e10b1ab2969b/Untitled.png)

`**Update` 쿼리가 실행 되면 커밋 관계 없이 InnoDB의 버퍼 풀은 “경기”로 바뀐다.**

또, 인서트 버퍼 부분에서 설명했다시피 디스크 데이터 파일에는 이벤트 발생에 따른 체크 포인트나 InnoDB의 백그라운드 스레드에 의해 새로운 값으로 업데이트 될 수도 있고 아닐 수도 있다.

만약, `Commit` 또는 `Rollback` 이 되지 않은 상태에서 다른 이용자가  `select` 쿼리로 작업 중인 레코드를 본다면????

```sql
SELECT * 
FROM member 
WHERE m_id = 12;
```

격리 수준에 따라 다르다. 격리 수준이 가장 낮은 READ_UNCOMMITTED인 경우 데이터가 커밋 됐든 아니든 변경된 상태의 데이터를 버퍼 풀이나 데이터 파일로부터 반환한다. READ_COMMITTED 이상 격리 수준인 경우 커밋되지 않았기에 언두 영역의 데이터를 반환한다. 이런 과정을 MVCC라고 한다.

즉, 하나의 레코드에 대해 2개의 버전, transaction이 유지되고 필요에 따라 어느 데이터가 보여지는지 달라진다. 위에서는 하나의 데이터만 가지고 얘기했지만 데이터가 많아지고 `Update` , `Insert` 쿼리가 많이 이루어 지고 그 데이터를 조회하면 언두 영역의 공간이 많이 필요할 수도 있다.

`Update` 쿼리가 실행되면 InnoDB 버퍼 풀은 즉시 새로운 데이터로 변경되며 기존 데이터는 언두로 복사되는 과정을 살펴봤는데, 만약 롤백이 되어버리면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고 언두 영역의 내용을 삭제한다. **또한, 커밋이 된다고 언두 영역의 데이터가 바로 삭제 되지 않고 트랜잭션이 끝났을 때 삭제된다.**

---

### 잠금 없는 일관된 읽기(Non-blocking Consistent Read)

InnoDB에서 격리 수준이 SERIALIZABLE이 아닌 모든 수준인 경우 트랜잭션 내에서 순수하게 `Select` 쿼리는 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행한다.

**만약 다른 사용자가 변경 쿼리를 실행하고 아직 커밋을 하지 않았음에도 `Select` 트랜잭션은 대기 하지 않고 바로 실행한다.**

그렇기 때문에 오랜 시간 동안 트랜잭션이 끝나지 않았을 경우 MySQL 서버가 느려질 수 있는데 이러한 경우는 잠금 없이 읽기를 수행하기 위해 언두 영역에서 로그를 삭제하지 못했기 때문에 발생하는 경우이다. **그렇기 때문에 트랜잭션이 시작되면 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.**