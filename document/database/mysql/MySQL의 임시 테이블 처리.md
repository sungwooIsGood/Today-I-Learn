**MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그룹핑할 때는 내부적인 임시 테이블을 사용한다.**

일반적으로 MySQL 엔진이 사용하는 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다.

**원본 테이블의 스토리지 엔진과 관계없이 임시 테이블이 메모리를 사용할 때는 MEMORY 스토리지 엔진을 사용하며, 디스크에 저장될 때는 MyISAM  스토리지 엔진을 이용한다.**

### 임시 테이블이 필요한 쿼리

- `ORDER BY`와 `GROUP BY`에 명시된 칼럼이 다른 쿼리
- `ORDER BY`나 `GROUP BY`에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- `DISTINCT`와 `ORDER BY`가 동시에 존재하는 경우 또는 `DISTINCT`가 인덱스로 처리되지 못하는 쿼리
- `UNION`이나 `UNION DISTICT`가 사용된 쿼리
- `UNION ALL`이 사용된 쿼리
- 쿼리의 실행 계획에서 select_type이 `DERIVED`인 쿼리

### 임시 테이블이 디스크에 생성되는 경우(MyISAM 스토리지 엔진을 사용함)

내부 임시 테이블은 기본적으로 메모리상에 만들어지지만 다음과 같은 조건에는 디스크 상에서 MyISAM 테이블로 만들어진다.

- 임시 테이블에 저장해야 하는 내용 중 BLOB(Binary Large Object)나 TEXT와 같은 대용량 칼럼이 있는 경우
- 임시 테이블에 저장해야 하는 레코드의 전체 크기나 UNION이나 UNION ALL에서 SELECT 되는 칼럼 중에서 길이가 512 바이트 이상인 크기의 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 임시 테이블에 저장할 데이터의 전체 크기가 tmp_table_size 또는 max_heap_table_size 시스템 설정 값보다 큰 경우

첫 번째부터 세 번째까지는 처음부터 디스크에 MyISAM 스토리지 엔진을 사용해서 내부 임시 테이블이 만들어진다. 하지만 네 번째는 처음에는 MEMORY 스토리지 엔진을 이용해 메모리에 내부 임시 테이블이 생성되지만 테이블의 크기가 시스템 설정 값을 넘어서는 순간 디스크의 MyISAM 테이블로 변환된다.

### 임시 테이블 관련 주의사항

**레코드 건수가 많지 않으면 내부 임시 테이블이 메모리에 생성되고 MySQL의 서버의 부하에 크게 영향을 미치지 않는다. 성능상 이슈가 될 부분은 내부 임시 테이블이 MyISAM 테이블로 디스크에서 생성되는 경우이다.**

예를 들어, 아래 쿼리는 GROUP BY와 ORDER BY 컬럼이 다르고, last_name 컬럼에 인덱스가 없기 때문에 임시 테이블과 정렬 작업까지 수행해야 하는 성능에 해가되는 형태이다.

```sql
SELECT *
FROM employees
GROUP BY last_name
ORDER BY first_name;
```

![Untitled](https://github.com/sungwooIsGood/Today-I-Learn/assets/98163632/93b010a5-c4bf-484b-b542-453941c74ad3)

Rows컬럼의 값을 보면 이 쿼리는 대략 처리해야 하는 레코드 건수가 30만 건 정도라는 사실을 알 수 있다.

1. Employees 테이블의 모든 컬럼을 포함한 임시 테이블을 생성(MEMORY 테이블)
2. Employees 테이블로부터 첫 번째 레코드를 InnoDB 스토리지 엔진으로부터 가져와서 임시 테이블에 같은 last_name이 있는지 확인
3. 같은 last_name이 없으면 임시 테이블에 `INSERT`
4. 같은 last_name이 있으면 임시 테이블에 `UPDATE`또는 무시한다.
5. 임시 테이블의 크기가 특정 크기보다 커지면 임시 테이블을 MyISAM 테이블로 디스크로 이동
6. Employees 테이블에서 더 읽을 레코드가 없을 때까지 2~6번 과정 반복, 위 쿼리는 30만 회 반복한다.
7. 최종 내부 임시 테이블에 저장된 결과에 대해 정렬 작업 수행
8. 결과 반환

**위에서 중요한 건 임시 테이블이 메모리에 있는 경우는 다르겠지만 디스크에 임시 테이블이 저장된 경우라면 30만 건을 임시 테이블로 저장하려면 적지 않은 부하가 발생한다.**

### 가능하다면,

- 인덱스 사용하고, 어렵다면 내부 임시 테이블이 메모리에만 저장될 수 있게 가공 대상 레코드를 적게 만드는 것이 좋다.
- 시스템 변수를 설정해서 메모리 가공 사이즈 늘리는 좋은 방법이 있지만 너무 크면 DB서버가 가용할 여유 메모리를 모두 사용할 수 있으므로 중간점 찾아야 한다.
- `SELECT` 하는 컬럼은 최소화 하고(특히 불필요하면 BLOB이나 TEXT 컬럼은 배제 하는게 제일 좋다.), 컬럼의 데이터 타입 선정도 가능한 작게 해주는 것이 좋다.
