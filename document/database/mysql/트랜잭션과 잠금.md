이전 장까지 mysql의 구조 및 InnoDB의 구조를 알아봤다면, 이번 장에는 트랜잭션에 대해 공부 해보고자 한다. 어플리케이션 개발을 하면서 트랜잭션에 대해 중요성은 몸소 느꼈지만 다소 부족한 부분이 많다고 생각한다. 그렇기 때문에 이번 장을 통해 트랜잭션에 대해 좀 더 많이 알아 가는 시간이 되었으면 한다.

본격적으로 들어가기 전 잠금(Lock)과 트랜잭션은 비슷한 개념으로 보이지만 **잠금은 동시성을 제어하기 위한 기능, 트랜잭션은 데이터의 정합성을 위한 기능!
동시에 변경과 잠금, 그리고 정합성 이제 알아보자.**

---

### 트랜잭션

앞 장에서 이야기 했듯이 InnoDB는 레코드 별 잠금을 제공한다고 했다. **트랜잭션은 모두 적용되거나 모두 적용되지 않아야 하는 상황에서 힘을 발휘한다.**

하지만 트랜잭션을 주의해서 사용해야 한다. DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 왜냐하면 트랜잭션의 범위를 최소화 해야하기 때문이다.
다음 한 상황을 예로 들어보자. 게시판에 게시물을 작성한 후 저장 버튼을 클릭했을 때 서버에서 처리하는 내용을 순서대로 정리했다.

```
1) 애플리케이션에서 처리 시작
-> 데이터 베이스 커넥션 생성
-> 트랜잭션 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 확인 
4) 첨부로 업로드 된 파일 확인 및 저장
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회 
8) 게시물 등록에 대한 알림 메일 발송
9) 알람 메일 발송 이력을 DBMS에 저장
<- 트랜잭션종료(COMIT)
<- 데이터 베이스 커넥션 반납 
10) 처리완료
```

위 상황은 흔히 일어날 수 있고, 또 개발자라면 위와 같이 처리하는 사람이 많을 것으로 예상이 간다. **하지만 위 절차 중에서 DBMS의 트랜잭션 처리에 좋지 않다은 부분이 있다.**

1. 데이터 베이스의 커넥션을 먼저 생성, 트랜잭션을 종료 시킨 후 데이터 베이스 커넥션 반납을 진행한다. **또, 실제로 DBMS에 데이터 저장하는 작업은 5번부터 시작한다. 2~4번은 DBMS의 트랜잭션으로 포함 시킬 필요가 없다.**
    1. 이 부분은 나도…. 흔히 했던 것 같다. 습관적으로 `@Transactional` 를 쓴 나 자신을 반성하며… 또, 데이터 베이스 커넥션 개수도 제한적이라서 해당 행위는 옳지 않았다…
2. 8번 로직! 이 부분이 핵심이다. 메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 **외부 자원과 통신하는 경우 DBMS의 트랜잭션 내에서 제거하는 것이 좋다. 왜냐하면 발송 로직에서 에러가 발생할 경우 DBMS 서버와 웹 서버 둘다 위험에 빠지게 된다.**
    1. 이 부분은 나도 생각했던 부분! 메일 및 알람 발송은 트랜잭션을 분리 하여 개발 해야한다. 때문에, 나는 spring에서 지원하는 이벤트를 사용했던 것 같다.(나 나름 성장했다…)
3. 위 절차에서 DBMS의 작업이 크게 4가지가 있다. 입력한 정보 저장, 5,6번 작업은 반드시 하나의 트랜잭션으로 묶는다. 7번 작업은 DBMS에 저장 한 후 단순 조회기 때문에 트랜잭션에 포함할 필요가 없다. 이는 별도 트랜잭션으로 분리해도 된다는 말이다 또한, 9번 작업 또한, 성격이 다르기 때문에 별도 트랜잭션으로 분리하는 것이 좋다.

위 상황들을 고려하여 다시 수정해보자.

```
1) 처리 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 발생 여부 확인
4) 첨부로 업로드 된 파일 확인 및 저장
-> 데이터 베이스 커넥션 생성
-> 트랜잭션 시작
5) 사용자의 입력 내용을 저장
6) 첨부 파일 정보 저장
<- 트랜잭션종료(COMMIT)
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회 
8) 게시물 등록에대한 알림 메일 발송
-> 트랜잭션 시작
9) 알림 메일 발송 이력을 DBNS에 저장
<- 드랜잭션종료(COMIT)
<- 데이터 베이스 커넥션 종료
10) 처리완료
```

위 설계가 최적의 설계는 아니지만 얘기하고자 하는 것은 **데이터 베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화 되어 있는 범위를 최소화 해야 한다는 것이다. 코드 라인 수는 한 두줄이라도 네트워크 작업이 있는 경우 반드시 트랜잭션에 배제해야한다. 실수로 인해 웹 및 DBMS 서버가 높은 부하로 빠지고 위험 상태가 된다.**

---

### MySQL 엔진의 잠금

MySQL에서 사용되는 잠금은 크게 **스토리지 엔진**레벨과 **MySQL 엔진 레벨**로 나눠서 볼 수 있다. MySQL 엔진레벨의 잠금은 모든 스토리지 엔진에 영향을 미치게 되지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다. **MySQL 엔진에서는 테이블 데이터 동기화를 위한 테이블 락말고 사용자 필요에 맞게 사용할 수 있는 유저 락과 테이블 명에 대한 잠금을 위한 네임 락이라는 것도 제공한다.**

- **글로벌 락**
   - MySQL에서 제공하는 잠금 가운데 가장 범위가 넓다**. 한 세션에서 글로벌 락을 획등하면 다른 세션에서 `Select` 을 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 대기 상태로 남는다.**
   - 글로벌 락이 미치는 영향은 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터 베이스가 다르다고 할지라도 동일하게 영향을 미친다.
   - 만약, 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백억을 받아야 할 때는 글로벌 락을 사용해야한다.

- **테이블 락(TABLE LOCK)**
   - **개별 테이블 단위로 설정되는 잠금이다.** 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다. 명시적인 테이블 락도 특벽한 상황이 아니라면 애플리케이션에서 거의 사용할 필요가 없다. 왜냐하면 테이블을 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문이다.
   - InnoDB 테이블의 경우 **스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지 않는다.** 더 정확하게는 InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경 쿼리에서는 무시되고 스키마를 변경하는 쿼리에 대해서만 영향을 미친다.

- **유저 락(USER LOCK)**
   - 이 잠금의 특징은 대상이 테이블이나 레코드 또는 데이터 베이스 객체가 아닌 **단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 잠금이다.** 유저락은 자주 사용되지는 않는다.

       ```sql
       -- 'mylock'이라는 문자열에 대해 잠금을 획득한다. 만약 잠금이 있다면 2초 대기
       SELECT GET_LOCK('myLock', 2):
       ```

   - 웹 서버가 어떤 정보를 동기화 해야하는 요건처럼 여러 클라이언트가 상호 동기화를 처리해야 할 때 데이터 베이스의 유저 락을 이용하면 쉽게 해결 할 수 있다.
   - 많은 레코드를 한 번에 변경하는 트랜잭션의 경우 유용하게 사용할 수 있다. 배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 되곤 한다. 이러한 경우 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 유저 락을 걸고 쿼리를 실행하면 간단하게 해결 할 수 있다.

- **네임 락(NAME LOCK)**
   - 데이터 베이스 객체에(테이블, 뷰 등)의 이름을 변경하는 경우 획득하는 잠금이다. 네임 락은 명시적으로 획득하거나 해제 할 수 있는 것이 아니고 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.
---
### InnoDB 스토리지 엔진의 잠금

InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 **레코드 기반의 잠금 방식을 탑재하고 있다. 레코드 기반 잠금 방식 때문에 다른 MyISAM보다 훨씬 뛰어난 동시성 처리를 제공할 수 있다. 하지만 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔지에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기 까다롭다. 하지만 MySQL 5.1 버전부터 플러그인 스토리지 엔진이 도입 되면서 트랜잭션과 잠금 그리고 잠금 대기중인 트랜잭션의 목록을 조회할 수 있다.**

- I**nnoDB의 잠금 방식**
    - **비관적 락**
        - **비관적 락이란 트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작하는 방법**
        - 이 처리 방식에서 느낄 수 있듯이 현재 변경 하고자 하는 레코드를 다른 트랜잭션에서도 변경 할 수 있다. **일반적으로 높은 동시성 처리에는 비관적 잠금이 유리하며, InnoDB는 비관적 잠금 방식을 채택하고 있다.**
    - **낙관적 락**
        - **DB에서 제공해주는 특징을 이용하는 것이 아닌 Application Level에서 잡아주는 Lock**
        - 낙관적락은 version과 같은 별도의 컬럼을 추가하여 충돌되는 쿼리를 막아준다.

- InnoDB의 잠금 종류
    - **레코드 락**
        - 레코드 자체만을 잠그는 것을 레코드 락이라고 한다. **InnoDB 스토리지 엔진은 레코드 자체가 아닌 인덱스의 레코드를 잠그는 특징을 가진다.**
        - 만약 인덱스가 하나도 없는 테이블이라 하더라도 내부적으로 자동 클러스터 인덱스를 이용해 잠금을 설정한다.
    - **갭 락**
        - 다른 DBMS와의 다른 차이가 바로 갭 락이다. 갭 락은 레코드 그 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다. 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(`Insert`)되는 것을 제어한다.
    - **넥스트 키 락**
        - 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다.
        - InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 낸 결과와 동일한 결과를 만들어 내도록 보장하는 것을 주 목적이다.
    - **자동 증가 락**
        - MySQL에서는 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT라는 컬럼 속성을 제공한다. AUTO_INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드가 `Insert` 되는 경우 저장되는 각 레코드는 중복 저장되지 않고 저장된 순서대로 증가한 일련번호를 가져야 하는데 **InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용한다.**
            - **AUTO_INCREMENT락은 Insert와 Replace 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하다.**
            - InnoDB의 다른 잠금들과 달리 AUTO_INCREMENT락은 트랜잭션과 관계없이  **Insert와 Replace 쿼리에서만 값을 가져올 때만 락이 걸린다.**
            - **AUTO_INCREMENT락은 테이블에서 단 하나만 존재하기 때문에 두 개의 Insert 쿼리가 동시에 실행되는 경우 하나의 쿼리가 AUTO_INCREMENT락에 걸리고 나머지 쿼리는 AUTO_INCREMENT락을 기다려야한다.**
            - **AUTO_INCREMENT락은 명시적으로 획득하고 해제하는 방법은 없다. AUTO_INCREMENT락은 아주 짧은 시간 동안 걸리기 때문에 문제되는 경우가 거의 없다.**