데이터 베이스 쿼리의 성능을 논하면 항상 등장 하는 키워드 중 하나가 바로 인덱스이다. 나는 이번 페이지에서 MySQL에서 사용 가능한 인덱스의 종류들의 특징들을 살펴보고 싶다.

---

### 랜덤 I/O와 순차 I/O

랜덤 I/O라는 표현은 디스크 드라이브의 원판을 돌려서 읽어야할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 사실 순차 I/O 또한 이 작업과 같다. 그렇다면 랜덤 I/O와 순차 I/O는 무슨 차이가 있을까?

![스크린샷 2024-03-05 오후 9.01.38.png](https://github.com/sungwooIsGood/Today-I-Learn/blob/main/images/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_1.png)

- 순차 I/O는 3개의 페이지(16x3KB)를 디스크에 기록하기 위해 1번 시스템 콜을 요청했지만, 랜덤I/O는 3개의 페이지를 디스크에 기록하기 위해 3번 시스템 콜을 요청한다.
    - 즉, 디스크에 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 1번 움직였고, 랜덤 I/O는 디스크 헤드를 3번 움직인것이다. 디스크에 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헫를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.
- 위 그림의 경우 순차 I/O는 랜덤 I/O보다 거의 3배 정도 빠르다고 볼 수있다. 즉, 디스크의 성능은 디스크 헤더의  위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐가 관건이다.
    - **그래서 여러 번 쓰기 또는 읽기를 요청하는 랜덤 I/O 작업이 훨씬 작업의 부하가 커지는 것이다.**
        - 똑같지는 않지만 실제 일을 하면서도 비슷한 경험을 한 것 같다. jpa의 hibernate batch를 이용해봤기에 위 상황이 쉽게 이해가 갔다. 쿼리를 쏠 때 네트워크를 여러번 타는 것 보다 한번 타는 것이 훨 낫다.(이거와 비슷한 이치라고 생각, 이해가 쉽게 되기 위한 나만의 생가….)
    - **데이터 베이스 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에는 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장된 것이다.**
- 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여는 것이 목적이라고 할 수 있다. → 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미

---

### 인덱스란?

본격적으로 인덱스를 살펴보자. DBMS도 데이터 베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값으로 인덱스를 만들어둔다. 그리고 책의 ‘찾아보기’와 인덱스의 공통점은 바로 정렬이다. **DBMS의 인덱스도 컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.**

프로그래밍 언어의 자료구로 인덱스와 데이터 파일을 간단하게 비교해보면

- 데이터 파일은 ArrayList와 같이 저장된 순서대로 별도 정렬 없이 그대로 정렬해둔다.
- 인덱스는 SortedList와 마찬가지로 저장되는 값을 항상 정렬된 상태로 유지시키는 자료구조로 데이터가 저장될 때마다 항상 값을 정렬해야하기 때문에 저장하는 과정이 복잡하고 느리지만, 이미 정렬 되어 있어 아주 빠르게 원하는 값을 찾아올 수 있는 장단점을 가지고 있다.

즉, DBMS의 인덱스도 **인덱스가 많은 테이블은 당연히 `Insert` 나 `Update` 그리고 `Delete` 쿼리 처리가 느리다. 그렇기 때문에 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지의 여부에 따라 결정되야 한다.**

하지만!

`Select` 쿼리 문장의 Where 조건절에 사용되는 컬럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러온다.

인덱스를 역할별로 구분해 본다면 프라이머리 키와 보조 키로 구분할 수 있다.

- **프라이머리 키**
    - **레코드를 대표하는 컬럼의 대표 값으로 만들어진 인덱스를 의미한다. PK가 걸린 컬럼은 해당 레코드를 식별할 수 있는 기준 값이 되기 때문에 중복 x, NULL 허용 x**
- **보조 키**
    - **PK와 성격이 비슷하지만 PK를 제외한 모든 인덱스는 보조 키로 분류한다.** 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수도 있다고 해서 대체 키라고도 한다.

대충 인덱스에 개념을 알았다면 인덱스가 어떤 알고리즘으로 이루어 졌는지 더 파헤쳐 보자.

---

### B-Tree 인덱스

데이터  베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘이다. B-Tree 알고리즘은 여러 번형된 형태의 알고리즘이 있는데, 일반적으로 B+-Tree 또는 B*-Tree가 사용된다.

아, 그리고 B의 약자로 이진을 뜻하는 바이너리로 생각할 수 있지만, Balanced를 의미한다.

B-Tree는 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 **항상 정렬된 상태로 유지하고 있다.** 위에서 언급한 SortedList와 비슷.

이제 구조와 특성을 알아보자.

- **트리 구조**
    - B-Tree는 트리 구조의 최상위 하나의 루트 노드가 존재하고 그 하위 노드가 붙어 있는 형태다. 트리 구조의 가장 하위에 있는 노드를 리프 노드라고  하며, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 브랜치 노드라고 한다.


- **데이터 관리**
    - 데이터 베이스에서 **인덱스와 실제 데이터가 저장된 데이터는 따로 관리 되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가지 위한 주소 값을 가지고 있다.**

  ![스크린샷 2024-03-05 오후 9.46.51.png](https://github.com/sungwooIsGood/Today-I-Learn/blob/main/images/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_2.png)

    - 위 사진에서 보이는 거와 마찬가지로 **인덱스의 키 값은 모두 정렬되어 있지만 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서대로 저장되어 있다. 데이터 파일은 `Insert` 순서대로 저장되지 않는다.**
    - 리프 노드를 제외한 나머지 노드들은 **인덱스의 레코드 값과 자식 노드 주소 값을 가지고 있어 리프 노드까지 탐색을 진행한다.**
    - 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼들을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.

      ![스크린샷 2024-03-05 오후 9.57.43.png](https://github.com/sungwooIsGood/Today-I-Learn/blob/main/images/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_3.png)

    - 레코드 주소는 DBMS 종류나 MySQL의 스토리지 엔진에 따라 의미가 달라진다. InnoDB 테이블에서는 PK에 의해 클러스터링이 되기 때문에 PK 값 자체가 주소 역할을 한다. **실제 MySQL 테이블의 인덱스는 항상 인덱스 컬럼 값과 주소 값의 조합이 인덱스 레코드로 구성된다.** 


- B-Tree 인덱스 추가 시 인덱스 관리
    - B-Tree에 저장 될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색한 후 저장될 위치가 결정 되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장 시킨다.
    - 리프 노드가 꽉 차면 브랜치 노드까지 처리범위가 넓어져 데이터 추가 시 상대적으로 비용이 많이 들게 된다. 단, InnoDB 스토리지 엔진은 insert가 실행되면 B-Tree인덱스에 바로 저장 시키지 않는다.
        - `Insert` 쿼리가 시작되면 InnoDB의 버퍼 풀에 새로운 키값을 추가해야 할 리프 노드가 존재한다면 즉시 추가한다. 만약 리프노드가 없다면 인서트 버퍼 풀에 임시로 기록하게 된다. 그 후 인덱스를 읽을 때마다 인서트 버퍼에 머지해야 할 인덱스가 있는지 확인하고 B-Tree에 인덱스 키와 주소를 저장한다. 또, 데이터베이스 서버 자원의 여유가 있다면 인서트 버퍼 머지 스레드가 조금씩 B-Tree에 저장 시킨다.


- B-Tree 인덱스 삭제 시 인덱스 관리
    - 삭제에는 간단하다. 리프 노드를 찾아 그냥 삭제 마킹처리를 진행한 후 방치하거나 재활용될 수 있다.


- B-Tree 인덱스 변경 시 인덱스 관리
    - 변경 시에는 저장될 리프 노드의 위치가 저장 되므로 B-Tree의 키값이 변경되는 경우 키 값을 삭제 한 후 다시 새로운 키 값을 추가하는 형태로 된다.

추가로, 중요하다고 생각되는 부분이 있다.

> B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. 부등호 비교(’<’, ‘>’)나 값의 뒷부분이 일치하는 경우 B-Tree 인덱스를 이용한 검색이 불가능하다.
또한 인덱스를 이용한 검색이 중요한 사실은 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다는 것이다. 이미 변형된 값은 B-Tree 인덱스에 존재하지 않는 값이다.
> 
>  때문에, B-Tree는 where 문의 점 조건, 앞 부분 탐색(like)시 탐색은 빠르지만 키 값이 아닌 레코드 값에 대해 부등호 비교나(between) 뒷부분 탐색이 불가능하여 쿼리 성능을 잘 비교하여 인덱스를 구성해야 한다.




---

### B -Tree 인덱스 사용에 영향을 미치는 요소

먼저, 내가 언급하지 않은 여러가지가 있지만 백엔드 개발자로써 중요하다고 생각되는 것을 적어 보았다.

1. **읽어야 하는 레코드의 건수**
    1. 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.
        1. 예를 들어 테이블에 레코드가 100만 건이 저장되어 있다고 가정하자. 그 중 50만 건을 읽어야 하는 쿼리가 있다고 하자. **이 작업은 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적일 지(풀스캔), 인덱스를 통해 필요한 50만 건만 읽어 오는 것이 효율적일지 판단하게 된다.**
        2. 일반적으로 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 더 비용이 든다고 예측한다.
        3. 즉, 인덱스를 통해 읽어야 할 레코드의 건수(옵티마이저 판단 건수)가 전체 테이블 레코드의 20~25%가 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는 필터링 방식으로 처리하는 것이 효율적이다.
        4. 그렇기 때문에 100만 건의 가정에서는 아마 20~25%가 넘기 때문에 MySQL 옵티마이저는 인덱스를 이용하지 않고 직접 테이블을 처음부터 끝까지 읽어서 처리할 것이다. 인덱스를 사용하고 싶어 힌트를 사용해도 되지만 성능상 이점이 없다.

---

### B -Tree 인덱스를 통한 데이터 읽기

어떤 경우에 인덱스를 유도할지, 사용 못하게 할지 판단 하려면 MySQL의 각 스토리지 엔진이 어떻게 인덱스를 이용해서 실제 레코드를 읽어 오는지 알고 있어야 한다.

1. **인덱스 레인지 스캔**
    - 인덱스의 접근 방법 가운데 가장 대표적인 접근 방식이다. 아래 쿼리로 예를 들어보자.

    ```sql
    SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'GAD';
    ```

    - **인덱스만을 읽는 경우**

      ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/942d92b2-2726-4773-953c-1779748455b0/Untitled.png)

        - 인덱스 레인지 스캔은 **검색해야 할 인덱스의 범위가 결정 됐을 때 사용하는 방법이다.** 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레이지 스캔이라고 표현한다.

        - 위 그림에서 알 수 있듯 루트 노드에서부터 비교를 시작해 브랜치 노드를 거쳐 최종적 리프 노드까지 들어가야만 실제 값을 찾을 수 있다. **시작해야 할 위치를 찾으면 그때부터 리프 노드의 레코드만 순서 대로 읽으면 된다. 그때부터 리프 노드 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 스캔한다.**

    - **데이터 파일의 레코드를 읽어와야 하는 경우**

      ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/559ef86e-56f0-484f-ba35-1c4312af1955/Untitled.png)

        - B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 특정 검색 값을 가지고 있는 리프 노드를 검색하고, 그 지점부터 필요한 방향(오름차순 or 내림차순)으로 인덱스를 읽어 나가는 과정을 확인 해볼 수 있다.

        - 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다. → 인덱스 특징(정렬)

        - 여기서 중요한 점은, 인덱스의 리프 노드에서 검색 조건에 일치하는 건들을 데이터 파일에서 읽어와야 한다. **이때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한번 씩 실행된다. 위 그림처럼 3건의 데이터를 찾기 위해 3번의 랜덤 I/O가 3번 필요하다.**
            - **그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 든다고 옵티마이저가 분류하고, 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리가 된 것이다.**


2. **인덱스 풀 스캔**
    - 인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다. **대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 풀 스캔 방식이 사용된다.**

    - 일반적으로 인덱스의 크기는 테이블의 크기보다 작기에 직접 테이블을 처음부터 끝까지 읽는 것보다 인덱스만 읽는게 효율적이다. **쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 이 방식이 사용된다. 인덱스 뿐만이 아니라 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리하면 안된다. → 즉 인덱스 안에서 해결, 데이터 파일을 거치지 않는다.**

      ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/3b51f466-04ae-4a82-a84f-87e4fb278f20/Untitled.png)

    - 그림에서 보이다시피 인덱스의 리프 노드를 연결하는 Linked list를 따라서 처음부터 끝까지 스캔하는 방식인 것이다. **이 방식은 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.**

    - 인덱스의 전체 크기는 테이블 자체의 크기보다는 훨씬 작으므로 **인덱스 풀 스캔은 테이블 전체를 읽는 것보다는 적은 디스크 I/O로 처리할 수 있다.**


3. **루스 인덱스 스캔**
    - 루스 인덱스 스캔이란 말은 **느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.**

      ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/205f315f-d9d5-4c28-b8ec-912fb55cded4/Untitled.png)

- 루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 작동하지만, **중간마다 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태이다. 일반적으로`Group By` 또는 집계 함수 가운데 `Max()` , `Min()` 함수에 최적화 하는 경우 사용된다. 아래 쿼리를 보고 이야기 해보자.**

```sql
SELECT dept_no MIN(emp_no)
FROM dept_emp
WHERE dep_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```

- `dept_emp` 테이블은 `dept_no`와 `emp_no` 두 개의 컬럼으로 인덱스가 생성되어 있다고 가정하자. 또, 이 인덱스는 `dept_no + emp_no` 의 값으로 정렬까지 되어 있어 위 그림과 같이 `dept_no` 그룹별로 제일 첫 번째 레코드의 `emp_no` 값만 읽으면 되는 것이다.

- 즉, 인덱스에서 `Where` 조건을 만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있기 때문에 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동한다. 리프 노드를 스캔 하면서 불필요한 부분은 무시하고 읽었다는 것을 볼 수 있다.

> **‘인덱스를 사용한다’는 말은 주로 인덱스 레인즈 스캔이나 루스 인덱스 스캔 방식을 의미한다. 인덱스 풀 스캔 방식은 인덱스를 이용하지만 그다지 효율적이지 않아 인덱스를 효율적으로 사용하지 못한다.**
>

---

### 다중 컬럼 인덱스

두 개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스라고 한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/7bf7535f-a843-4449-9921-3d61a9a06db2/Untitled.png)

- 루트 노드는 생략하였지만 실제로 데이터 레코드 건수가 작은 경우에는 브랜치 노드가 없는 경우도 있을 수 있다. **인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되어 있다. 즉, 두 번째 컬럼의 정렬은 첫 번째 컬럼이 똑같은 레코드에서만 의미 있다는 것이다!**

- 앞서 예를 든 것처럼 `emp_no` 값의 정렬 순서가 빠르다 하더라도 `dept_no` 컬럼의 정렬 순서가 늦다면 인덱스의 뒤쪽에 위치한다. 그래서 위 그림처럼 emp_no 값이 10003인 레코드가 인덱스 리프 노드의 제일 하단에 위치하는 것이다.

- **즉, 다중 컬럼 인덱스에서 인덱스 내에서 각 컬럼의 위치가 상당히 중요하며 또 아주 신중히 결정해야 하는 이유가 바로 이것이다.**
