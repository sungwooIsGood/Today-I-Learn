MySQL의 실행 계획에 대해 알게 되었는데, 디테일하게 알고가면 좋을 것 같아 공부해보고자 한다.

MySQL은 내부적으로 MySQL 엔진과 스토리지 엔진으로 크게 나누어 볼 수 있는데, MySQL엔진에서 부가적으로 처리하는 작업은 대부분 성능에 영향이 크다. 이는 곧 쿼리의 성능을 저하시키기도 한다.

스토리지 엔진에서 읽은 레코드를 MySQL 엔진이 아무런 가공작업도 하지 않고 사용자에게 반환 한다면 최상의성능을 보장하는 쿼리가 되겠지만 사실상 힘들다. 이제부터 어떤 것들이 MySQL 엔진이 오래걸리게 되는 것인지 알아보자.

---

### 풀 테이블 스캔

풀 테이블 스캔은 인덱스를 거의 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.

옵티마이저가 풀 테이블 스캔을 타는 조건

- **테이블의 레코드 건수가 너무 작아서** 인덱스틑 통해 읽는 것보다 풀테이블 스캔을 하는 편이 더 빠른 경우
- WHERE 절이나 ON 절에 인**덱스를 이용할 수 있는 적절한 조건이 없는 경우**
- **인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우**
- 반대로, max_seeks_for_key 변수를 특정 값으로 설정하면 Mysql 옵티마이저는 인덱스의 기수성이나 선택도를 무시하고, 최대N 건만 읽으면 된다고 판단하게 된다. 이값을 작게 설정할수록 Mysql 서버가 인덱스를 더 사용하도록 유도함.

### Order BY 처리(Using filesort)

조금만 개발 해본 사람도 레코드 1~ 2건을 가져오는 쿼리를 제외하면 대부분의 `SELECT` 쿼리에서 정렬은 필수적으로 사용된다는 것을 알 것이다.

정렬을 처리하기 위해서는 인덱스를 이용하는 방법과 쿼리가 실행될 때 "Filesort"라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.

| 구분 | 장점 | 단점 |
| --- | --- | --- |
| 인덱스를 이용 | Insert,Udate,Delete 쿼리가 실행될때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다. | Insert,Udate,Delete 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. |
| FileSort 이용 | 인덱스를 생성하지 않으므로 인덱스의 단점이 장점으로 바뀐다. | 정렬 작업이 쿼리 실행시 처리 되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다. |

다음과 같은 경우 정렬 인덱스를 이용하기 쉽지 않은 상황이다. → ‘**Using filesort’**

- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTICT가 사용된 쿼리
- UNION ALL이 사용된 쿼리
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

### 소트 버퍼(Sort buffer)

MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당 받아서 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다. 소트 버퍼는 정렬이 필요한 경우에만 할당 되며, 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.

![스크린샷 2024-04-16 오후 9 35 46](https://github.com/sungwooIsGood/Today-I-Learn/assets/98163632/f8650253-ccee-4078-9766-dee3e22b491d)

위에는 이상적이지만 왜 문제가 되는지 한번 살펴보자. 만약 레코드의 건수가 많아서 소트 버퍼로 할당된 공간보다 크다면 어떻게 될까. **MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용한다.**

메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록해 둔다. 그리고 그 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장한다.

**이 작업들이 모두 디스크의 쓰기와 읽기를 유발하며, 레코드 건수가 많을수록 이 반복 작업의 횟수가 많아진다.**

### 정렬 알고리즘

레코드를 정렬할 때, **레코드 전체를 소트 버퍼에 담을지** 또는 **정렬기준 칼럼만 소트버퍼에 담을지**에 따라 2가지 알고리즘으로 나눠 볼수 있다.

- **싱글 패스(Single pass) 알고리즘**

소트버퍼에 정렬 기준 칼럼을 포함해 `SELECT` 되는 칼럼 전부를 담아서 정렬을 수행하는 방법이며, 정렬이 완료 되면 버퍼의 내용을 그대로 클라이언트로 넘겨준다.

![스크린샷 2024-04-16 오후 9 50 35](https://github.com/sungwooIsGood/Today-I-Learn/assets/98163632/3a1e6a2e-9351-4db4-825c-fa79005a4fc5)

- 투 패스(Two pass) 알고리즘

정렬 대상 칼럼과 프라이머리 키값만을 소트 버퍼에 담아서 정렬을 수행하고 → 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 `SELECT` 할 칼럼을 가져오는 알고리즘이다. (예전 Mysql 에서 사용하던 방법이다. 최근은 싱글 패스 방식을 사용한다.)

하지만 싱글 패스 알고리즘을 사용하지 않는 경우는 다음과 같다.

- 레코드의 크기가 max_length_for_sort_data 파라미터로 설정된 값보다 클때
- **BLOB 이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할때**

> `SELECT` 쿼리에서 꼭 필요한 칼럼만 조회하지 않고, 모든칼럼(’*’)을 가져오도록 개발할때가 많다. 하지만 이는 정렬 버퍼를 몇배에서 몇십배까지 비효율적으로 사용하게 만들 가능성이 크다. `SELECT` 쿼리에서 꼭 필요한 칼럼만 조회하도록 쿼리를 작성하는 것이 좋다. 또, 정렬 뿐 아니라 임시 테이블이 필요한 테이블에도 영향을 미치기 때문에 ‘*’ 사용은 자제 해야한다. 

### 정렬의 처리 방식

쿼리에 ORDER BY가 있으면 다음 3가지 처리 중 하나로 정렬이 처리된다.

| 정렬 처리 방법 | 실행 계획의 Extra 코멘트 |
| --- | --- |
| 인덱스 사용한 정렬 | 별도 내용 x |
| 드라이빙 테이블만 정렬
(조인이 없는 경우 포함) | ‘Using filesort’ |
| 조인 결과를 임시 테이블로 저장한 후, 임시 테이블에서 정렬 | ‘Using temporary; Using filesort’ |

옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지 검토 하는데, 만약 인덱스를 이용한다면 별도의 **Filsort** 과정 없이 반환한다.

반대로 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(Filsort)할 것이다.

옵티마이저는 정렬 대상 레코드를 최소화 하기 위해 다음 두가지 방법중 한가지를 선택한다.

1. 드라이빙 테이블만 정렬한 다음 조인을 수행
2. 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

첫 번째 방법이 더 효율적으로 처리된다. 다음은 세가지 정렬 방법을 알아보자.

1. **인덱스를 이용한 정렬**
    1. **인덱스를 이용한 정렬을 위해 반드시 `ORDER BY`에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고**, **`ORDER BY` 순서대로 생성된 인덱스가 있어야 한다.(복합 인덱스 혹 단일 인덱스)**
    2. **`WHERE`절에 첫 번째 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.** 단, B-Tree 계열만 가능하다.
    3. **추가로 인덱스의 값이 정렬되어 있기 때문에 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지 않는다. 아래 예시에서 `ORDER BY emp_no` 부분이 없어도 같은 순서로 출력이 될 것이다.**
       하지만, emp_no 컬럼으로 정렬이 필요한데, 인덱스를 사용하면서 자동 정렬 된다고일부러 ORDER BY emp_no를 제거하는 건 좋지 않다.

        ```sql
        -- employees 테이블의 PK(emp_no)
        SELECT *
        FROM employees e, salaries s
        WHERE s.emp_no=e.emp_no
        AND E.EMP_NO between 100002 AND 100020
        ORDER BY e.emp_no;
        ```

       ![Untitled](https://github.com/sungwooIsGood/Today-I-Learn/assets/98163632/a09fa4d4-6199-46fd-8c38-ea0db33c38a5)

2. **드라이빙 테이블만 정렬**
    1. 일반적으로 조인이 수행되면 결과 레코드의 건수가 몇 배로 불어난다. 그래서 **조인을 실행 전 첫 번째 테이블 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이다. 그래서 이 방법은 조인에 첫 번째 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 ORDER BY 절에 작성되어야 한다.**

        ```sql
        SELECT *
        FROM employees e, salaries s
        WHERE s.emp_no=e.emp_no
        AND E.EMP_NO between 100002 AND 100020
        ORDER BY e.last_name;
        ```

    2. 위 조건이 다음 두 가지 조건을 갖추고 있기 때문에 옵티마이저는 employees 테이블을 트라이빙 테이블로 선택한다.
        1. 1. `WHERE`절의 검색 조건 - `E.EMP_NO between 100002 AND 100020` 은 employees 테이블의 PK를 이용해 검색하면 작업량을 줄일 수 있다.
        2. 2. 드라이븐 테이블(salaries)의 조인 컬럼인 emp_no 컬럼에 인덱스가 있다.
    3. 검색은 인덱스 레인지 스캔으로 처리할 수 있지만 `ORDER BY`절에 명시된 컬럼은 empoyees 테이블의 PK와 전혀 연관이 없으므로 **인덱스를 이용한 정렬이 불가능하다. 그런데, `ORDER BY` 절의 정렬 기준 컬럼이 드라이빙 테이블(employees)에 포함된 컬러임을 알 수 있다. 옵티마이저는 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고, 그 결과와 salaries 테이블을 조인한 것이다.**
       ![Untitled (1)](https://github.com/sungwooIsGood/Today-I-Learn/assets/98163632/c00192a4-7f8c-41d8-8d74-07f6eadc0aa7)

3. **임시 테이블을 이용한 정렬**
    1. 쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 `SELECT` 해서 정렬하는 경우라면 임시 테이블이 필요하지 않다. 하지만 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다.
    2. **드라이빙 테이블 정렬은 2개 이상의 테이블이 조인되면서 정렬이 실행되지만 임시 테이블을 사용하지 않는다.**
    3. 임시 테이블 이용한 정렬 방법은 위 두가지 방법보다 **가장 느린 정렬 방법**이다.
       드라이빙 테이블 정렬과 같은 쿼리지만 ORDER BY에서 salaries 테이블의 컬럼을 가지고 정렬을 하게 되면서 드라이븐 테이블로 사용된 것이다. 이렇게 되면서 **반드시 조인된 데이터를 정렬할 수 밖에 없다.**

        ```sql
        SELECT *
        FROM employees e, salaries s
        WHERE s.emp_no=e.emp_no
        AND E.EMP_NO between 100002 AND 100020
        ORDER BY s.salary;
        ```

       ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/b69e7d84-fba4-4f1b-84d7-bfc804493388/Untitled.png)



### 정렬 처리 방법의 성능 비교

나와 같이 웹/앱 개발자들이 사용하는 쿼리에서 `ORDER BY` 와 함께 `LIMIT`가 거의 필수로 사용된다. `LIMIT`는 테이블이나 처리 결과의 일부만 가져오기 때문에 MySQL 서버가 처리해야 할 작업량을 줄이는 역할을 한다.

**그러나, `ORDER BY`나 `GROUP BY` 같은 작업은 `WHERE` 조건을 만족하는 레코드를 `LIMIT` 만큼 가져와서 처리하는 건 불가능하다. 조건을 만족하는 레코드를 모두 가져와 정렬 또는 그루핑 작업을 실행해야 비로소 `LIMIT`로 건수를 제한할 수 있다.**

즉, `WHERE` 조건이 아무리 튜닝이 잘한다고 해도 `ORDER BY` 나 `GROUP BY` 때문에 쿼리가 느려는 경우가 자주 발생한다.

쿼리에서 인덱스를 사용하지 못하는 정렬이나 그루핑이 왜 느리게 작동하는 지는 다음 쿼리를 처리하는 두 가지 방법을 보면 알 수 있다.

- **스트리밍 처리**

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/e763abd5-0b5e-4060-ac02-d7c5e91ebbb4/Untitled.png)

    - **서버쪽에서 처리할 데이터가 얼마인지 관계없이 조건에 일치하는 레코드가 검색될 때 마다 즉시 클라이언트로 전송해주는 방식이다.**
    - 마지막 쿼리를 언제 받을지 알 수 없다. → 클라이언트 입장에서 중요x
        - 덕분에 `LIMIT` 를 사용하면 전체 실행 시간을 많이 줄일 수 있다.
    - 조건에 맞는 레코드를 검색하면서 데이터 가공 작업 수행 가능
- **버퍼링 처리**

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/1ac65145-d34a-4154-beae-4b645b4037f3/Untitled.png)

    - **조건에 맞는 모든 레코드를 가져와서 한 번에 클라이언트에게 전송해주는 방식이다.**
    - `ORDER BY`, `GROUP BY` 는 스트리밍이 불가능하므로 이 방식 사용된다.`WHERE` 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그룹핑을 해서 차례대로 보내야 하기 때문이다.
    - MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느려지는 것이다.
    - 위 그림과 같이 버퍼링 처리되는 쿼리는 먼저 결과를 모아서 MySQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로부터 가져올 때 기다려야 한다. 그래서 MySQL은 일괄적으로 데이터 가공을 해야하기에 `LIMIT` 사용이 성능 향상에 별로 도움이 되지 않는다. 이는 네트워크로 전송되는 레코드 건수를 줄일 수 있지만 MySQL 서버가 해야 하는 작업량에는 변화가 없다.

위 `ORDER BY` 쿼리의 3가지 정렬 처리 방법 중 **인덱스 사용 방식이 스트리밍 형태 처리이며, 나머지는 모두 버퍼링 후 정렬된다.**