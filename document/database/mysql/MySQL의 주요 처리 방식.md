MySQL의 실행 계획에 대해 알게 되었는데, 디테일하게 알고가면 좋을 것 같아 공부해보고자 한다.

MySQL은 내부적으로 MySQL 엔진과 스토리지 엔진으로 크게 나누어 볼 수 있는데, MySQL엔진에서 부가적으로 처리하는 작업은 대부분 성능에 영향이 크다. 이는 곧 쿼리의 성능을 저하시키기도 한다.

스토리지 엔진에서 읽은 레코드를 MySQL 엔진이 아무런 가공작업도 하지 않고 사용자에게 반환 한다면 최상의성능을 보장하는 쿼리가 되겠지만 사실상 힘들다. 이제부터 어떤 것들이 MySQL 엔진이 오래걸리게 되는 것인지 알아보자.

---

### 풀 테이블 스캔

풀 테이블 스캔은 인덱스를 거의 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.

옵티마이저가 풀 테이블 스캔을 타는 조건

- **테이블의 레코드 건수가 너무 작아서** 인덱스틑 통해 읽는 것보다 풀테이블 스캔을 하는 편이 더 빠른 경우
- WHERE 절이나 ON 절에 인**덱스를 이용할 수 있는 적절한 조건이 없는 경우**
- **인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우**
- 반대로, max_seeks_for_key 변수를 특정 값으로 설정하면 Mysql 옵티마이저는 인덱스의 기수성이나 선택도를 무시하고, 최대N 건만 읽으면 된다고 판단하게 된다. 이값을 작게 설정할수록 Mysql 서버가 인덱스를 더 사용하도록 유도함.

### Order BY 처리(Using filesort)

조금만 개발 해본 사람도 레코드 1~ 2건을 가져오는 쿼리를 제외하면 대부분의 `SELECT` 쿼리에서 정렬은 필수적으로 사용된다는 것을 알 것이다.

정렬을 처리하기 위해서는 인덱스를 이용하는 방법과 쿼리가 실행될 때 "Filesort"라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.

| 구분 | 장점 | 단점 |
| --- | --- | --- |
| 인덱스를 이용 | Insert,Udate,Delete 쿼리가 실행될때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다. | Insert,Udate,Delete 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. |
| FileSort 이용 | 인덱스를 생성하지 않으므로 인덱스의 단점이 장점으로 바뀐다. | 정렬 작업이 쿼리 실행시 처리 되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다. |

다음과 같은 경우 정렬 인덱스를 이용하기 쉽지 않은 상황이다. → ‘**Using filesort’**

- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTICT가 사용된 쿼리
- UNION ALL이 사용된 쿼리
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

### 소트 버퍼(Sort buffer)

MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당 받아서 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다. 소트 버퍼는 정렬이 필요한 경우에만 할당 되며, 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.

![스크린샷 2024-04-16 오후 9.35.46.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/5466476a-a7e6-487d-b2d9-042e9f4cb16e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.35.46.png)

위에는 이상적이지만 왜 문제가 되는지 한번 살펴보자. 만약 레코드의 건수가 많아서 소트 버퍼로 할당된 공간보다 크다면 어떻게 될까. **MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용한다.**

메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록해 둔다. 그리고 그 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장한다.

**이 작업들이 모두 디스크의 쓰기와 읽기를 유발하며, 레코드 건수가 많을수록 이 반복 작업의 횟수가 많아진다.**

### 정렬 알고리즘

레코드를 정렬할 때, **레코드 전체를 소트 버퍼에 담을지** 또는 **정렬기준 칼럼만 소트버퍼에 담을지**에 따라 2가지 알고리즘으로 나눠 볼수 있다.

- **싱글 패스(Single pass) 알고리즘**

소트버퍼에 정렬 기준 칼럼을 포함해 `SELECT` 되는 칼럼 전부를 담아서 정렬을 수행하는 방법이며, 정렬이 완료 되면 버퍼의 내용을 그대로 클라이언트로 넘겨준다.

![스크린샷 2024-04-16 오후 9.50.35.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4208ea1-f20c-48bd-b05a-8f485cb16b9b/c73fc96c-a1e0-462f-8d1d-b07b0fe577f6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.50.35.png)

- 투 패스(Two pass) 알고리즘

정렬 대상 칼럼과 프라이머리 키값만을 소트 버퍼에 담아서 정렬을 수행하고 → 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 `SELECT` 할 칼럼을 가져오는 알고리즘이다. (예전 Mysql 에서 사용하던 방법이다. 최근은 싱글 패스 방식을 사용한다.)

하지만 싱글 패스 알고리즘을 사용하지 않는 경우는 다음과 같다.

- 레코드의 크기가 max_length_for_sort_data 파라미터로 설정된 값보다 클때
- **BLOB 이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할때**

> `SELECT` 쿼리에서 꼭 필요한 칼럼만 조회하지 않고, 모든칼럼(’*’)을 가져오도록 개발할때가 많다. 하지만 이는 정렬 버퍼를 몇배에서 몇십배까지 비효율적으로 사용하게 만들 가능성이 크다. `SELECT` 쿼리에서 꼭 필요한 칼럼만 조회하도록 쿼리를 작성하는 것이 좋다. 또, 정렬 뿐 아니라 임시 테이블이 필요한 테이블에도 영향을 미치기 때문에 ‘*’ 사용은 자제 해야한다.
>