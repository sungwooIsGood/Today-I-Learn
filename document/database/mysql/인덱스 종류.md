### 해시(Hash) 인덱스

일단 들어가기 앞서 해시 인덱스는 B-Tree만큼 범용적이지 않지만 고유의 특성과 용도를 지닌 인덱스 가운데 중 하나이다. **해시 인덱스는 특히 동등 비교 검색에는 최적화 되어 있다. 하지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없다는 것을 알 필요가 있다.**

**해시 인덱스는 메모리 기반의 테이블에 주로 구현(key-value)되어 있으며, 디스크 기반의 대용량 테이블용으로는 거의 사용 되지 않는다는 특징이 있다.** 해시 인덱스 알고리즘은 테이블의 인덱스 뿐 아니라 InnoDB의 버퍼 풀에서 빠른 레코드 검색을 위한 어댑티브 해시 인덱스(Adaptive Hash Index)로 사용되기도 하고, 또, 오라클과 같은 DBMS에서는 JOIN에 사용되기도 한다.

다시한번 언급하지만 **해시 인덱스는 주로 메모리 기반의 테이블에서 주로 사용**되지만 기본적인 특성은 반드시 알아두자.


- **구조 및 특성**

<img width="401" alt="스크린샷 2024-03-10 오후 1 31 55" src="https://github.com/sungwooIsGood/Today-I-Learn/assets/98163632/f3eb1b0d-8fe6-4f9c-ad62-2efee899a3a5">

  위 이미지에서 괄호 안의 값은 해시 함수가 실행되기 이전의 원본 값임.


  **해시 인덱스의 큰 장점은 실제 키값과는 관계없이 인덱스 크기가 작고 검색이 빠르다는 것이다. 위의 그림에서 보는 것 처럼 해시 인덱스는 트리 형태의 구조가 아니므로 검색하고자 하는 값을 주면 해시 함수를 거쳐 찾고자 하는 키 값이 포함된 버킷을 찾는다. 그리고 버킷 하나만 읽어서 비교해 보면 실제 레코드가 저장된 위치를 바로 알 수 있다.**


  **그렇기 때문에 여러 노드를 내려가면서 읽는 B-Tree보다 상당히 빠른 결과를 반환 한다.**

  해시 인덱스는 원래 키값을 저장하는 것이 아니라 해시 함수의 결과(일반적으로 단순 숫자값)만을 저장하므로 키 값의 값이 아무리 길어도 실제 해시 인덱스에 저장되는 값은 4~8바이트 수준으로 상당히 줄어든다.

  **해시 인덱스에서 가장 중요한 것은 해시 함수로, 입력된 키 값이 어디에 저장될지를 결정하는 함수다.**

  해시 함수의 결과 값의 범위가 넓으면 그만큼 버킷에 많이 필요해져서 공간의 낭비가 커지고, 값의 범위가 너무 작으면 충돌되는 경우가 많이 발생해 해시 인덱스의 장점이 사라진다. → 충돌, 해시 함수의 결과 값이 같은 경우

  간단하게 알아보자.

    ```sql
    해시 함수 F(value) = CRC32(value) % 10
    
    F('Banette') = 7
    F('Aamer') = 9
    F('Jaana') = 9
    ```

  CRC16이라는 함수의 결과 값을 10으로 나눈 결과 나머지 값을 취하는 것으로 해시 함수를 정의한 것이다. 위에서 `Jaana` , `Aamer` 의 값이 9라는 것을 볼 수 있는데 이를 충돌이라고 표현한다. **해시 함수 결과 값의 범위가 좁으면 필요한 버킷의 개수가 적어지지만 충돌이 많고, 반대로 해시 함수 결과 값의 범위가 넓으면 버킷의 개수가 많이 필요해져 충돌이 줄어든다. 충돌이 많다는 것은 검색 효율이 떨어지는 것이다.**

  > 해시 알고리즘은 여러가지 목적으로 사용될 수 있지만 DBMS에서는 주로 인덱스와 테이블의 파티셔닝 용도로 사용된다. 
  >  
  > 검색을 위해 해시 알고리즘이 사용되는 경우에는 해시 함수의 결과 값이 범위가 넓어야 충돌이 줄어들고 그만큼 검색 성능이 높아진다. 
  > 
  > 하지만 테이블의 파티셔닝 용도로 사용되는 경우에는 해시 함수가 필요한 파티션의 개수 만큼만 만들어 내도록 설계해야 하므로 해시 함수의 결과 값의 범위를 좁게 사용한다. 그렇기 때문에 MySQL의 해시 파티션은 이러한 알고리즘으로 파티셔닝하는 기능을 한다.

---

### 해시 인덱스의 가용성 및 효율성

**해시 인덱스는 빠른 검색을 제공하지만 키 값 자체가 변환되어 저장되기 때문에 범위를 검색하거나 원본 값 기준으로 정렬할 수 없다. 해시 인덱스는 이렇게 원본 키값이 변하기 때문에 어떤 방식으로도 해시 인덱스를 사용하지 못하는 경우도 발생한다.**

- **작업 범위 제한 조건으로 해시 인덱스를 사용하는 쿼리**
  - 다음 패턴의 쿼리는 동등 비교조건으로 값을 검색하고 있으므로 해시 인덱스의 빠른 장점을 이용할 수 있다.

    ```sql
    WHERE column = 'aa';
    WHERE column <=> 'aa';
    WHERE column IN ('aa','bb');
    WHERE column IS NULL;
    WHERE column IS NOT NULL;
    ```


- **해시 인덱스를 사용하지 못하는 쿼리**
  - 작업 범위 결정 조건뿐 아니라 체크 조건의 용도로도 전혀 사용할 수 없다.

```sql
WHERE column = >= 'aa';
WHERE column BETWEEN 100 AND 120;
WHERE column LIKE 'aa%';
WHERE column <> 'aa';
```

**해시 인덱스를 사용할 때, 다중 컬럼으로 생성된 해시 인덱스에서도 모든 컬럼이 동등 조건으로 비교되는 경우에만 인덱스를 사용할 수 있다.**

---

### 클러스터링 인덱스

클러스터란 여러 개를 하나로 묶는다는 의미로 주로 사용된다. 인덱스의 클러스터링도 그 의미를 벗어나지 않는다. 인덱스에서 클러스터링은 값이 비슷한 것들을 묶어서 저장하는 형태로 구현된다.

주로, 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안한 것이다. MySQL에서 클러스터링 인덱스는 InnoDB와 TokuDB 스토리지 엔진에서만 지원한다.

- **클러스터링 인덱스**
  - 클러스터링 인덱스는 테이블의 PK에만 적용되는 내용이다.
  - 즉, PK 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 한다. 여기서 중요한 것은 PK 값에 의해 레코드의 저장 위치가 결정된다.  또, PK 값이 변경되면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미하기도 한다. **PK값으로 클러스터링 된 테이블은 PK 값 자체에 대한 의존도가 상당히 크기 때문에 신중히 PK를 설정해야한다.**
  - 클러스터링 인덱스는 사실 인덱스 알고리즘 보다 **테이블 레코드의 저장 방식**이라고 볼 수 있다.
  - **일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 PK 기반의 검색이 매우 빠르다. 대신, 레코드의 저장이나 PK 값 변경은 느릴 수 밖에 없다.**

> B-Tree를 공부하면서 B-Tree에서도 인덱스는 항상 정렬되어 있다고 배웠는데, 그 정렬과 클러스터링 인덱스랑은 다르다. **테이블의 레코드가 PK 값으로 정렬되어 저장된 경우에만 클러스터링 인덱스라고 한다.**
>

![Untitled (2)](https://github.com/sungwooIsGood/Today-I-Learn/assets/98163632/0cf207f7-b1ca-407e-bee9-4c3dc8321188)

위 이미지를 보면 B-Tree와 상당히 비슷하다. 하지만 B-Tree의 리프 노드와는 달리 **클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장되어 있다. 즉, 클러스터링 인덱스는 그 자체가 하나의 거대한 인덱스 구조로 관리된다.**

아래 코드를 통해 어떤 변화가 있는지 살펴보자.

```sql
UPDATE test SET emp_no = 10002 WHERE emp_no = 10007;
```

위 그림을 보면 `emp_no` 가 10007인 레코드는 3번째 페이지에 저장되어있다. 만약, emp_no가 10002로 변경 되면서 2번째 페이지로 이동하게 된다. 실제로 PK의 값이 변경되는 경우는 거의 없지만 PK 값을 변경을 통해 어떻게 되는지 살펴본 것이다.

![Untitled (3)](https://github.com/sungwooIsGood/Today-I-Learn/assets/98163632/384cfd56-623b-4555-900a-5b7cd4aa2701)

만약 PK나 유니크 인덱스가 없는 경우 InnoDB 테이블에서는 아무런 의미 없는 숫자 값으로 클러스터**링 되고 있는 것이다. 아무런 혜택 또한 없다.**

**InnoDB 테이블에서 PK는 클러스터링 인덱스의 기준이 되기에 클러스터링 인덱스는 단 한번만 가질 수 있는 엄청난 것이기에 꼭 PK를 명시하는 습관을 들이자.**

### 보조 인덱스에 미치는 영향

PK가 데이터 레코드 저장에 미치는 영향을 알아봤다면, PK가 보조 인덱스에 어떤 영향을 미치는지 알아보자.

클러스터 키값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주소 값을 변경해야 한다. 이런 번거로움 때문에 **InnoDB 테이블에서는 모든 보조 인덱스는 해당 레코드가 저장된 주소가 아니라 PK 값을 저장하도록 구현되어 있다.**

`Employees` 테이블을 통해 알아보자. `first_name` 컬럼으로 검색하는 경우.

```sql
CREATE TABLE employees(
	emp_no INT NOT NULL,
	first_name VARCHAR(20) NOT NULL,
	PRIMARY KEY (emp_no)
	INDEX ix_firstname (first_name)
);

SELECT * FROM employees WHERE first_name = 'Aamer';
```

InnoDB에서는 **ix_firstname 인덱스를 검색해 레코드의 PK 값을 확인하며, PK 값을 이용해 다시 한번 테이블을 검색한 후 최종 레코드를 가져온다. PK로 레코드를 읽어 오는 과정은 매우 빠르기에 성능을 걱정할 필요는 없다.**

### 클러스터 인덱스의 장단점

- 장점
  - PK로 검색할 때 처리 성능이 매우 빠르다.
  - 테이블의 모든 보조 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다. 이를 커버링 인덱스라고 한다.
- 단점
  - 테이블의 모든 보조 인덱스가 클러스터 키를 갖고 있기 때문에 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커진다.
  - 보조 인덱스를 통해 검색할 때 PK 키로 다시 한번 검색해야하기 때문에 성능이 조금 느릴 수 있다.
  - PK 값을 변경할 때 레코드를 `Delete`하고 `Insert`하는 작업이 필요하기 때문에 처리 성능이 느리다.

### 클러스터 인덱스 사용 시 주의사항

클러스터 인덱스를 사용하기에 몇 가지 주의 사항들을 알아보자.

1. **PK 키는 AUTO-INCREMENT보다는 업무적인 컬럼으로 생성할 것(**난 습관적으로 auto-increment를 사용했다….. 왜 안되는지 살펴보자….**)**
  1. PK로 검색하는 경우 클러스터 되지 않은 테이블에 비해 매우 빠르게 처리된다. MyISAM과 같이 클러스터되지 않는 테이블에서 사실 PK로 뭘 선택해도 성능상 큰 차이가 없지만 InnoDB에서는 엄청난 차이를 만들어 낸다.
  2. 또, PK는 그 의미만큼이나 중요한 역할을 하기 때문에 대부분 검색에서 상당히 빈번하게 사용되는 것이 일반적이다. 설령 컬럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 컬럼을 PK로 설정하는 것이좋다.
2. **PK는 반드시 꼭 명시하자.**
3. **AUTO-INCREMENT 컬럼을 인조 식별자로 사용할 경우**
  1. 만약 보조 인덱스도 필요하고 PK의 크기도 길다면 **AUTO-INCREMENT 컬럼을 추가하고 이를 PK로 설정하면 된다. 이렇게 PK를 대체하기 위해 인위적으로 추가된 PK를 인조 식별자라고 한다.** 조회 보다는 Insert 위주의 테이블은 AUTO-INCREMENT를 이용한 인조 식별자를 PK로 설정하는 것이 성능 향상에 도움이 된다.

---

### 유니크 인덱스

유니크란 사실 인덱스보단 제약조건에 가깝다. **말 그대로 테이블이나 인덱스에 같은 같이 2개 이상 저장될 수 없다. MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.** 그래서 MySQL에서는 **PK는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동으로 부여**된다.

### 유니크 인덱스와 일반 보조 인덱스의 비교

유니크 인덱스와 유니크하지 않는 일반 보조 인덱스는 사실 인덱스 구조상 아무런 차이가 없다.

- **인덱스 읽기**
  - 많이들 유니크 인덱스가 빠르다고 생각 하지만 실은 아니다. 유니크 하지 않은 보조 인덱스에서 한 번 더 해야하는 작업은 디스크 읽기가 아니라 CPU에서 컬럼값을 비교하는 작업이기 때문에 성능상 영향이 거의 없다.
  - 유니크하지 않은 보조 인덱스는 중복된 값이 허용되므로 읽어야할 레코드가 많아서 느린 것인지, 인덱스 자체 특성이 느린 것은 아닌 것이다.
- **인덱스 쓰기**
  - 새로운 레코드가 `Insert` 되거나 인덱스 컬럼의 값이 변경되는 경우에는 인덱스 쓰기 작업이 필요하다. 그런데 **유니크 인덱스의 키값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 번 더 필요하다.  그래서 일반 보조 인덱스의 쓰기보다 느리다.**
  - **MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 빈번히 발생한다.**
  - InnoDb 스토리지 엔진에는 인덱스 키의 저장을 버퍼링하기 위해 Insert Buffer가 사용된다. 그래서 인덱스의 저장이나 변경 작업이 상당히 빨리 처리 되지만 안타깝게도 유니크 인덱스는 반드시 중복 체크를 해야하기 때문에 버퍼링을 사용하지 못하다. **때문에, 유니크 인덱스는 일반 보조 인덱스 보다 더 느려진다.**

### 유니크 인덱스 사용 시 주의사항

먼저, 유니크 인덱스를 써야하면 당연히 써야 하지만 결론부터 말하자면 **더 성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지 않는 편이 좋다.**

또, 하나의 테이블에서 같은 컬럼에 유니크 인덱스와 일반 인덱스를 각각 중복해서 생성해 둔 경우가 가끔 있는데, **MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복해서 인덱스를 생성할 필요가 없다.**

더 나아가 PK와 유니크 인덱스를 동일하게 생성한 테이블도 있는데, 이 또한 불필요한 중복이므로 주의하자.

---

### 외래키

MySQL에서 외래키는 **InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다. 만약 레코드 값을 제거 하고 싶으면 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.**

두 가지 특징을 먼저 봐보자.

- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
- 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.

```sql
CREATE TABLE tb_parent (
	id INT NOT NULL,
	fd VARCHAR(100) NOT NULL,
	PRIMARY KEY (id)
) ENGINE = INNODB;

CREATE TABLE tb_child (
	id INT NOT NULL,
	pid INT DEFAULT NULL, -- parent.id 컬럼 참조
	fd VARCHAR(100) DEFAULT NULL,
	PRIMARY KEY (id),
	KEY ix_parentid (pid),
	CONSTRAINT child_ibfk_1 FOREIGN KEY (pid) REFERENCES tb_parent (id) ON DELETE CASCADE
) ENGINE=INNODB;

INSERT INTO tb_parent VALUES (1,'parent-1'), (2, 'parent-2');
INSERT INTO tb_child VALUES (100,1,'child-100');
```

위와 같이 쿼리문을 통해 잠금이 어떻게 되는지 알아보자.

- **자식 테이블의 변경이 대기하는 경우**

| 작업 번호 | 커넥션-1 | 커넥션-2 |
| --- | --- | --- |
| 1 | BEGIN; |  |
| 2 | UPDATE tb_parent SET fd=' changed-2' WHERE id=2; |  |
| 3 |  | BEGIN; |
| 4 |  | UPDATE tb_child SET pid=2 WHERE id=100; |
| 5 | ROLLBACK; |  |
| 6 |  | Query OK, 1 row affected (3.04 sec) |

1번 커넥션에서 먼저 트랜잭션을 시작하고 부모(tb_parent) 테이블에서 id = 2인 레코드에 `Update` 를 실행한다.

이 과정에서 1번 커넥션이 tb_parent 테이블에서 id=2인 레코드에 대해 쓰기 잠금을 획득한다.

2번 커넥션에서 자식 테이블(tb_child)의 외래키 컬럼인 pid를 2로 변경하는 쿼리를 실행해보자. 이 쿼리는 부모 테이블의 변경 작업이 완료될 때까지 대기한다. 부모 테이블의 변경 작업이 끝나면 바로 쿼리가 처리되는 것을 볼 수 있다.

즉, 자식 테이블의 외래키 컬럼의 변경은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다리게 되는 것이다. 이것이 InnoDB의 외래키 관리의 첫 번째 특징에 해당한다.

- **부모 테이블의 변경 작업이 대기하는 경우**

| 작업 번호 | 커넥션-1 | 커넥션-2 |
| --- | --- | --- |
| 1 | BEGIN; |  |
| 2 | UPDATE tb_child SET fd='changed-100' WHERE id=100; |  |
| 3 |  | BEGIN; |
| 4 |  | DELETE FROM tb_parent WHERE id=1; |
| 5 | ROLLBACK; |  |
| 6 |  | Query OK, 1 row affected (6.09 sec) |

위 과정을 보면 자식 테이블이 부모키 ‘1’을 참조하는 자식 테이블의 레코드를 변경하면 `tb_child` 테이블의 레코드에 대해 쓰기 잠금을 획득한다.

2번 커넥션에서 `tb_parent` 테이블의 레코드를 삭제하려면 4번 작업은 쓰기 잠금이 해제될 때까지 기다려야 한다. 이는 자식 테이블이 생성될 때 정의된 외래키의 특성(`ON DELETE CASCADE`) 때문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제 되도록 작동 하기 때문이다.

---

### 추가로,

인덱스는 MySQL 엔진 레벨이 아니라 스토리지 엔진 레벨에 포함되는 영역이므로 스토리지 엔진의 종류별로 사용 가능한 인덱스의 종류가 다르다. InnoDB에서는 B-Tree 인덱스 알고리즘을 지원한다.
