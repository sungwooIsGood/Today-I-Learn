# My SQL 아키텍처

이번 장을 시작으로 My SQL에 대해 약 한 달 동안 집중적으로 공부해볼 예정이다. 개발자로 지내오면서 DB에 대해 많은 것들을 놓치고 또 너무 얕게 알고 있다는 느낌이 강했다. 그렇기 때문에 한 단계 성장한 개발자가 되려면 DB의 동작 방식이나 구조 정도는 기본 소양이라고 생각한다.

참고로, Real MySQL을 정리하면서 추가적인 나의 생각들과 자료들을 종합한 내용이다.

또, MySQL 5.5부터 **InnoDB가 기본으로** **채택 되었기에 InnoDB**를 기준으로 공부해 볼 예정이다.

---

### MySQL 전체 구조

![Untitled](https://github.com/sungwooIsGood/Today-I-Learn/blob/main/images/mysql_structure.png)

MySQL 서버는 크게 **MySQL 엔진**과 **스토리지 엔진**으로 구분할 수 있다. 또, 구분한 이 두 부분을 합쳐서 MySQL 또는 MySQL 서버라고 표현할 수 있다.

- **MySQL 엔진**
    - MySQL 엔진은 클라이언트의 접속, 요청을 담당하는 **커넥션 핸들러**와 **SQL 파서**, **전처리기**, **옵티마이저**로 이루어져 있다. 또, 성능 향상을 위해 InnoDB의 **버퍼 풀**과 같은 보조 저장소가 포함 되어있다.
- **스토리지 엔진**
    - **SQL 문장을 분석하거나 최적화 하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다. 또, 실제 데이터를 디스트 스토리지에 저장하거나 데이터를 읽어오는 부분을 담당한다.** MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다. 아래와 같이 스토리지 엔진을 지정할 수 있으며 지정하면 정의된 스토리지 엔진이 처리하게 된다.

    ```sql
    CREATE TABLE test_table (fd1 INT, fd2 INT) ENFINE=INNODB;
    ```

- **핸들러 API**
    - MySQL 엔진의 쿼리 실행에서 데이터를 읽거나 써야 할 때 스토리지 엔진에게 read, write 요청을 하는데 이것을 핸들러 요청이라고 하고, 여기서 사용되는 API를 핸들러 API라고 한다. InnoDB 스토리지 엔진 또한 이 핸들러 API를 이용해 MySQL 엔진과 데이터를 주고 받는다. **즉, 스토리지 엔진과 MySQL 엔진 사이 요청전달 역할을 한다.**

---

### MySQL 스레딩 구조

![Untitled](https://github.com/sungwooIsGood/Today-I-Learn/blob/main/images/mysql_thread_structure.png)

먼저, MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 작동하며, 크게는 **포그라운드 스레드**와 **백그라운드 스레드**로 구분한다.

- **포그라운드 스레드(클라이언트 스레드)**
    - 포그라운드 스레드 **최소한 MySQL 서버에 접속한 클라이언트 수만큼 존재,** **주 역할은 클라이언트 사용자가 요청한 쿼리 문장을 처리**한다. 클라이언트가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 풀로 돌아간다. 스레드 풀에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 풀에 존재한다. 때문에 풀에 너무 많은 스레드를 저장하지 않는다. 파라미터로는 **‘thread_cache_size’ 이다.** 해당 **스레드는 데이터 버퍼나 캐시로부터 데이터를 가져오며 버퍼나 캐시에 없는 경우 디스크나 인덱스 파일로부터 데이터를 읽어와서 처리한다. 단, InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드가 담당하고 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.**

  이 스레드는 백엔드 개발자로써 쉽게 이해할 수 있는 부분이다. 클라이언트가 백엔드, DB가 서버 역할을 함으로 Connection 접속 객체를 통해 DB와 연결하는 부분을 생각하면 쉽게 이해할 수 있다.

- **백그라운드 스레드**
    - InnoDB에서 백그라운드 스레드는 포그라운드 스레드가 하지 않는 다양한 역할들을 한다. 인서트 버퍼를 병합하는 스레드 역할, 로그를 디스크로 기록하는 스레드, 버퍼 풀의 데이터를 디스크에 기록하는 스레드, 데이터를 버퍼로 읽어들이는 스레드, 잠금과 관련하여 데드락을 모니터링 하는 스레드, 모든 것을 총괄하는 메인 스레드가 존재한다.

---

### 쿼리 실행 구조

![Untitled](https://github.com/sungwooIsGood/Today-I-Learn/blob/main/images/mysql_build_structure.png)

위에서 MySQL 구조를 살펴 보았다. 구조를 알았다면 쿼리가 어떻게 실행되는지 궁금한건 당연지사! 하나씩 자세하게 살펴보자.

**‘클라이언트가 SQL 요청을 MySQL 서버로 보냈다.’**

MySQL 서버 안에서 가장 먼저 만나게 되는 부분은 MySQL엔진 안에 있는 쿼리 파서 부분이다.

1. **쿼리 파서**
    1. 사용자 요청으로 들어온 쿼리 문장을  토큰(MySQL이 인식할 최소 단위 - [ex) `select`, `update` 등])으로 분리해 트리 형태 구조로 만들어 **쿼리 문장의 기본 문법 오류를 찾아내 사용자에게 반환한다.**

쿼리 파서 부분에서 문법 오류가 없으면 다음은 **전처리기**로 쿼리문이 전달된다.

1. **전처리기**
    1. 쿼리 파서에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점을 확인한다. **토큰을 테이블 이름, 컬럼 이름 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체 접근 권한 등을 확인한다.** 실제 존재하지 않는 테이블, 컬럼, 내장함수, 권한 등이 없다면 이 단계에서 걸러진다.

전처리기까지 온 쿼리는 일단 쿼리의 기본 문법, 접근 권한, 테이블, 컬럼, 내장 함수 등을 합격한 쿼리문이다. 그렇다면 이제 이 쿼리문을 실행을 해야한다. 그치만 바로 실행하는 것이 아니라 **DBMS의 두뇌! 옵티마이저**로 보낸다.

1. **옵티마이저**
    1. 해당 영역은 요청 받은 쿼리문을 가장 저렴하고 빠르게 처리할지 결정하는 장소다.

옵티마이저 즉, 두뇌에서 어떻게 처리하면 가장 빠른지 결정됐다. 그 다음 실행 엔진(쿼리 실행기)으로 실행 계획과 쿼리문을 전달한다.

1. **실행 엔진**
    1. 옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발 ‘**생각에 맞춰 하는 행동들’** 이라고 이해하면 좋다. GROUP BY를 처리하기 위해 임시 테이블 사용을 예로 들어보자.
        1. 실행 엔진은 핸들러에게 임시 테이블을 만들라는 요청을 한다.
        2. 또, 실행 엔진은 WHERE 절에 일치하는 레코드를 읽으라고 핸들러에게 요청한다.
        3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 핸들러에게 요청한다.
        4. 임시테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 요청한다.
        5. 최종적으로 실행 엔진은 결과를 사용나 다른 모듈로 넘기게 된다.

**즉, 실행 엔진은 옵티마이저가 정한 실행 계획대로 핸들러에게 요청해서 받은 결과를 또 다른 핸들러에게 요청, 입력하는 역할을 수행한다.**

- **핸들러(스토리지 엔진)**

핸들러는 MySQL 서버의 가장 밑단인 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장, 읽어오는 역할을 한다. 결국 핸들러는 스토리지 엔진을 의미한다. InnoDB 테이블을 조작하는 경우에는 InnoDB 스토리지 엔진이 핸들러가 된다.

---

### 쿼리 캐시

![Untitled](https://github.com/sungwooIsGood/Today-I-Learn/blob/main/images/mysql_caching.png)

위에서 설명했던 **복잡한 쿼리 절차로 만들어진 결과 값을 쿼리 캐시에 담아 두고, 동일한 쿼리 요청이 왔을 때 간단하게 쿼리 캐시에서 찾을 수 있다.** 이는 엄청난 효과로 가져올 수 있다. 하지만 이 쿼리 캐시에도 장단점이 있어 이점을 알고 사용하는 것이 매우 중요하다.

**쿼리 캐시는 단어의 의미와 달리 SQL 문장을 캐시하는 것이 하는 것이 아니다. 이를 아는 것이 중요하다.**
쿼리 캐시는 **쿼리의 결과를 메모리에 캐시해 두는 기능이다!!**

쿼리 캐시의 구조는 키와 값으로 관리되는 MAP과 같은 형태로 구현되어 있다. **키를 구성하는 요소로 가장 중요한 것은 쿼리 문자 자체이며, 값은 해당 쿼리의 실행 결과로 나온다라고 생각하기 쉽다.**

과연 그런지 확인 절차들을 하나씩 뜯어보자.

1. **요청된 쿼리 문장이 쿼리 캐시에 존재하나?**
    - 쿼리 캐시는 위 사진을 보면 알 수 있듯이 MySQL에서의 가장 앞에 위치하여, 캐시 데이터를 뒤진다. 같은 쿼리 문장인지 비교 하는 방식은 **요청된 쿼리 문장 자체**가 동일한지 여부를 확인한다. 즉, 공백이나 탭과 같은 문자까지 포함이다. 대소문자도 완전히 동일해야 같은 쿼리로 인식한다. 어느 하나라도 틀리다면 쿼리 캐시에 있는 데이터를 받지 못한다.
      그렇다면 **나 같은 백엔드 개발자는 전체 쿼리 가운데 동일한 결과, 비슷한 작업을 하는 쿼리는 하나의 쿼리로 통일해 문자열 혹은 변수로 관리하는 것이 좋아 보인다.**
2. **권한 확인**
    - 테이블 읽기 권한이 없다면 보여줘서는 안되기 떄문에 클라이언트의 권한 여부를 확인하는 것은 당연할 것이다.
3. **트랜잭션 내 실행된 쿼리인 경우 가시 범위 내에 있는 결과인가?**
    - 우린 InnoDB를 사용하고 있다. InnoDB의 모든 트랜잭션은 각 ID를 갖게 된다. 격리 수준 때문에 트랜잭션의 ID는 순서를 가지고 있다. 자신의 ID 값보다 큰 ID 값이 변경한 작업 내용은 참조할 수 없다. 이를 가시 범위라고 하는데, 캐시에서도 ID가 가시 범위 내에서만 사용할 수 있다. **즉, 나보다 ID 값이 큰 트랜잭션의 변경 내용을 캐시에서 가져올 수 없다.**
4. `**CURRENT_DATE(), SYSDATE(), RAND()` 등과 같이 호출에 따라 값이 달라지는 요소인가?**
    - 위 함수같은 경우 호출한 시점에 마다 값이 달라진다. 이러한 함수들은 쿼리 캐시의 데이터를 가져올 수 없다.
5. **캐시가 만들어지고 난 후 다른 클라이언트에 의해 변경 되었는가?**
    1. 이미 변경된 데이터를 캐시하는 것은 의미가 없기 때문에 데이터를 제거해야 한다. 위에서 말한 것처럼 빠른 처리를 위해 구조는 아주 간단하게 설계되어 있다.
    2. 또, 알아야할 중요한 사실은 쿼리 캐시에 있는 데이터를 제거하는 작업은 레코드 단위가 아닌 테이블 단위로 처리한다. 그렇기 떄문에 만약 캐시가 1GB로 크게 설정 되어있고, 하나의 테이블로부터 조회된 데이터로 쿼리 캐시가 꽉 채웠다고 가정해보자. 만약 테이블에 새로운 레코드를 한 건 INSERT 하면 MySQL 서버는 쿼리 캐시에 있는  1GB의 내용을 모두 제가한다. 그리고 메모리 작업이지만 많은 시간이 소모 된다.
6. 쿼리에 의해 만들어진 결과가 캐시로 쓰기엔 너무 크지 않은지.
    1. query_cache_limit 파라미터 설정으로 캐시의 크기를 설정할 수 있다. 이 파라미터로 만들어진 캐시의 미만 값들만 저장하게 된다. 1~2M 미만으로 설정하는 것이 일반적이며 GROUP BY, DISTINCT와 같이 그룹 집계함수를 캐시에다 넣는 것이 아주 적합하다.

쿼리 캐시는 `SHOW GLOBAL STATUS` 명령어를 통해 얼마나 사용되는지 알 수 있다. `Qcache_hits`는 실제로 쿼리 캐시로 처리된 `select` 문 수를 의미한다. 반대로 `Com_select` 는 쿼리 캐시에서 결과를 찾지 못해 MySQL 서버가 쿼리를 실행한 횟수를 의미한다. 여기서 `Qcache_hits` + `Com_select` 는 MySQL 서버로 요청된 모든 `select`문을 의미한다.

여기서 우린 쿼리 캐시 히트율 `Qcachehits/(Qcache _hits+Com_select)*100` 을 구할 수 있다. 쿼리 캐시 히트율이란 쿼리가 날라올 때 캐시를 탄 퍼센트이다. 흔히 20% 이상이면 일반적으로 쿼리 캐시를 사용하는 것이 좋다고 이야기 한다. 이 지표를 통해 쿼리 캐시를 사용할지 사용하지 않을지 설정하면 된다.

히트율 그건 잘 모르겠고, 그냥 무조건 쓰면 좋은거 아닌가? 라는 생각이 들 수 있는데, 우린 캐시 또한 메모리라는 점을 항상 인지하고 있어야 한다. 즉, 캐시 또한 요건에 따라 써야한다.

그래야 쓸 때없는 메모리 낭비도 없고, MySOL. 서버가 쿼리 캐시를 검색 하거나 제거하는데 필요한 오버헤드도 줄일 수 있다.
